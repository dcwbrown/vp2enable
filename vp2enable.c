// Enable VP2 serial port

#include <stdint.h>

#define F_CPU 8000000UL
#include <util/delay.h>

#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>

#define MOSI PB0
#define MISO PB1
#define SCK  PB2
#define SS   PB4

#define StatusCmd    0xD7
#define StatusRsp    0x8C
#define SecurityCmd  0x77
const uint8_t SecurityRsp[] PROGMEM =
{
  0x00, 0x00, 0x00,
  0x80, 0x2D, 0x22, 0x6F, 0x52, 0x6F, 0x98, 0xA9, 0x21, 0x25, 0x5E, 0x2D, 0x2D, 0x31, 0xD2, 0x39,
  0x18, 0x1C, 0x63, 0x0C, 0x31, 0x21, 0x2D, 0x39, 0x90, 0xDE, 0x94, 0x6F, 0x6B, 0x77, 0x73, 0x7F,
  0x63, 0x8C, 0x88, 0x84, 0x80, 0x9C, 0x98, 0x94, 0x90, 0xAD, 0xA9, 0xA5, 0xA1, 0xBD, 0xB9, 0xB5,
  0xB1, 0xCA, 0xCE, 0xC2, 0xC6, 0xDA, 0xDE, 0xD2, 0xD6, 0xEB, 0xEF, 0xE3, 0xE7, 0xFB, 0xFF, 0xF3,
  0x0B, 0x02, 0x16, 0x17, 0x11, 0x15, 0x1F, 0x22, 0x00, 0x00, 0x46, 0x00, 0xFF, 0xFF, 0xAC, 0xFF,
  0x30, 0x30, 0x4D, 0x32, 0x36, 0x39, 0x37, 0x31, 0x0F, 0x1C, 0x0C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};


uint8_t SpiTransfer(uint8_t out) {
  USIDR = out;
  USISR = (1<<USIOIF);
  while (!(USISR & (1<<USIOIF))); // Wait for transfer complete
  return USIDR;
}

int main() {
  uint16_t i;

  _delay_ms(100);

  DDRB  = 0;                          // Initially all pins are inputs
  PORTB = (1<<SCK)|(1<<MOSI)|(1<<SS); // Enable pullups on SCK, MOSI and SS
  USICR = (1<<USIWM0)|(1<<USICS1);    // SPI slave mode

  sei();

  while (1) {
    while (PINB & (1 << PB4)); // Wait for SS to go low
    DDRB  = (1<<MISO);         // MISO is output, rest are inputs
    switch (SpiTransfer(0)) {

      case StatusCmd:
        SpiTransfer(StatusRsp);
      break;

      case SecurityCmd:
        for (i=0; i<sizeof(SecurityRsp); i++)
          SpiTransfer(pgm_read_byte(&SecurityRsp[i]));
      break;
    }
    DDRB = 0;                  // Release MISO to other SPI clients
  }
}
